<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>A-Frame • Autospawn Poppable Spheres + Breathy Pad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    html,body { margin:0; height:100%; }
    .hint {
      position:fixed; left:12px; bottom:12px; z-index:10;
      background:#0008; color:#fff; padding:8px 12px; border-radius:10px;
      font:14px/1.3 system-ui; max-width:80vw;
    }
  </style>
</head>
<body>
  <div class="hint">Tap/click spheres to pop them. New spheres spawn automatically. (Audio plays on pop.)</div>

  <a-scene renderer="colorManagement:true; physicallyCorrectLights:true">
    <!-- Camera with mouse/touch ray -->
    <a-entity id="rig" position="0 0 0">
      <a-entity id="cam"
        camera
        position="0 1.6 0"
        look-controls
        wasd-controls
        cursor="rayOrigin: mouse; fuse: false"
        raycaster="objects: .clickable; far: 100">
      </a-entity>
    </a-entity>

    <!-- Lights + simple environment -->
    <a-entity light="type: ambient; intensity: 0.9"></a-entity>
    <a-entity light="type: directional; intensity: 0.8" position="0 4 3"></a-entity>
    <a-plane rotation="-90 0 0" width="60" height="60" color="#FFE2DE"></a-plane>
    <a-sky color="#f6fbff"></a-sky>
  </a-scene>

  <script>
    const scene = document.querySelector('a-scene');
    const cam   = document.querySelector('#cam');

    // ---- TUNABLES ----
    const SPAWN_INTERVAL_MS = 600;
    const MAX_SPHERES       = 120;
    const DESPAWN_MS        = 20000; // auto-remove if not popped

    // === AUDIO (Web Audio, inline, no external files) ===
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function envGain(duration, attack = 0.005, release = 0.15, peak = 0.25) {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(peak, now + attack);
      // ensure we never release before duration
      g.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(attack + release, duration));
      return g;
    }

    function playPop() {
      const dur = 0.12;
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      const now = audioCtx.currentTime;
      osc.frequency.setValueAtTime(700, now);
      osc.frequency.exponentialRampToValueAtTime(180, now + dur);
      const g = envGain(dur, 0.002, 0.12, 0.35);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + dur + 0.02);
    }

    function playChime() {
      const now = audioCtx.currentTime;
      const notes = [440, 493.88, 587.33, 659.25, 783.99]; // A4, B4, D5, E5, G5
      const f = notes[Math.floor(Math.random()*notes.length)];
      const dur = 0.9 + Math.random()*0.5;

      // triangle tone with a little vibrato, lightly filtered
      const osc = audioCtx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(f, now);

      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 5.2;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 3.5;
      lfo.connect(lfoGain);
      lfoGain.connect(osc.frequency);

      const g = envGain(dur, 0.015, 0.8, 0.18);
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(4000, now);

      osc.connect(lp).connect(g).connect(audioCtx.destination);
      lfo.start(now);
      osc.start(now);
      osc.stop(now + dur + 0.05);
      lfo.stop(now + dur + 0.05);
    }

    // --- Breathy pad that "slows down": slow attack, pitch glide down, low-pass sweep ---
    function playBreathyPad() {

      const now = audioCtx.currentTime;
      const padDur = 2.6;              // total tail ~2.6–3.0s
      const attack = 0.18, release = 2.2;

      // (A) Air layer: filtered noise for breathiness
      // Build a short looped white-noise buffer
      const length = Math.floor(audioCtx.sampleRate * 2.0);
      const noiseBuf = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for (let i = 0; i < length; i++) data[i] = Math.random() * 2 - 1;

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuf;
      noise.loop = true;

      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(4500, now);
      // sweep darker over time (feels like slowing/settling)
      lp.frequency.exponentialRampToValueAtTime(900, now + padDur);

      const noiseGain = envGain(padDur, attack, release, 0.10);

      // (B) Tone layer: gentle triangle that glides down in pitch
      const tone = audioCtx.createOscillator();
      tone.type = 'triangle';
      const startF = 560 + Math.random()*140; // 560–700 Hz
      const endF   = startF * 0.52;           // glide down ~ a 5th
      tone.frequency.setValueAtTime(startF, now);
      tone.frequency.exponentialRampToValueAtTime(endF, now + 1.8);

      const toneLP = audioCtx.createBiquadFilter();
      toneLP.type = 'lowpass';
      toneLP.frequency.setValueAtTime(3200, now);
      toneLP.frequency.exponentialRampToValueAtTime(900, now + padDur);

      const toneGain = envGain(padDur, attack, release, 0.08);

      // Optional subtle stereo width via two panners
      const splitter = audioCtx.createChannelSplitter(2);
      const merger   = audioCtx.createChannelMerger(2);
      const panL = audioCtx.createStereoPanner(); panL.pan.value = -0.15;
      const panR = audioCtx.createStereoPanner(); panR.pan.value =  0.15;

      // Routing
      noise.connect(lp).connect(noiseGain);
      tone.connect(toneLP).connect(toneGain);

      // Mix
      const mix = audioCtx.createGain();
      mix.gain.value = 1.0;

      noiseGain.connect(mix);
      toneGain.connect(mix);

      // Slight width
      mix.connect(splitter);
      splitter.connect(panL, 0);
      splitter.connect(panR, 1);
      panL.connect(merger, 0, 0);
      panR.connect(merger, 0, 1);

      const out = audioCtx.createGain();
      out.gain.value = 1.0;
      merger.connect(out).connect(audioCtx.destination);

      // Start / stop
      noise.start(now);
      tone.start(now);
      noise.stop(now + padDur + 0.1);
      tone.stop(now + padDur + 0.1);
    }

    function popSound() {
      ensureAudio();
      // Pop immediately
      playPop();
      // Add chime shortly after for sparkle
      setTimeout(() => playChime(), 20 + Math.random()*40);
      // Add breathy pad that swells + slows down
      setTimeout(() => playBreathyPad(), 40 + Math.random()*60);
    }

    // Distinct hues (evenly spaced)
    let sphereCount = 0;
    function nextColor() {
      const hue = (sphereCount * 47) % 360;
      sphereCount++;
      return `hsl(${hue}, 80%, 55%)`;
    }

    // Poppable behavior
    AFRAME.registerComponent('pop-on-click', {
      init() {
        this.popped = false;
        const pop = () => {
          if (this.popped) return;
          this.popped = true;
          this.el.classList.remove('clickable');

          // Play layered sound
          popSound();

          // Scale to zero
          this.el.setAttribute('animation__pop', {
            property: 'scale',
            from: this.el.getAttribute('scale') || '1 1 1',
            to: '0 0 0', dur: 220, easing: 'easeInBack'
          });
          // Fade opacity (material must be transparent)
          const mat = this.el.getAttribute('material') || {};
          const fromOpacity = (typeof mat.opacity === 'number') ? mat.opacity : 1;
          this.el.setAttribute('animation__fade', {
            property: 'material.opacity', from: fromOpacity, to: 0, dur: 200, easing: 'linear'
          });
          setTimeout(() => this.el.remove(), 240);
        };
        this.el.addEventListener('click', pop);
        this.el.addEventListener('mousedown', pop);
        this.el.addEventListener('touchstart', pop, {passive:true});
      }
    });

    function makeBobbingSphere(pos, radius){
      const s = document.createElement('a-sphere');
      s.classList.add('clickable');
      s.setAttribute('position', pos);
      s.setAttribute('radius', radius.toFixed(3));
      s.setAttribute('material', `color: ${nextColor()}; opacity: 1; transparent: true; metalness: 0; roughness: 0.4`);
      s.setAttribute('shadow', 'cast:true; receive:false');
      s.setAttribute('pop-on-click', '');

      // gentle bobbing
      const [px, py, pz] = pos.split(' ').map(Number);
      const amp = 0.05 + Math.random()*0.07;     // 5–12 cm
      const dur = 2000 + Math.random()*1500;     // 2–3.5 s
      s.setAttribute('animation__bob',
        `property: position; dir: alternate; dur: ${dur}; loop: true; to: ${px} ${(py+amp).toFixed(3)} ${pz}`);

      // optional timed despawn (if not popped)
      if (DESPAWN_MS > 0) {
        setTimeout(() => {
          if (!s.isConnected) return; // already popped/removed
          s.classList.remove('clickable');
          s.setAttribute('animation__fadeout', {
            property: 'material.opacity', from: 1, to: 0, dur: 350, easing: 'linear'
          });
          s.setAttribute('animation__shrink', {
            property: 'scale', to: '0 0 0', dur: 350, easing: 'easeInBack'
          });
          setTimeout(() => s.remove(), 360);
        }, DESPAWN_MS);
      }
      return s;
    }

    function spawnNearCamera() {
      // Respect max cap: remove oldest sphere if necessary
      const all = scene.querySelectorAll('a-sphere');
      if (all.length >= MAX_SPHERES) all[0]?.remove();

      const camWorldPos = new THREE.Vector3();
      cam.object3D.getWorldPosition(camWorldPos);

      const r = 2 + Math.random()*6;                 // 2–8 m away
      const theta = Math.random()*Math.PI*2;
      const x = camWorldPos.x + Math.cos(theta)*r;
      const z = camWorldPos.z + Math.sin(theta)*r;
      const y = 0.5 + Math.random()*2.0;             // 0.5–2.5 m high

      const radius = 0.1 + Math.random()*0.7;        // 0.1–0.8 m
      const sphere = makeBobbingSphere(`${x} ${y} ${z}`, radius);
      scene.appendChild(sphere);
    }

    // Kick off with a few, then autospawn forever
    for (let i=0;i<12;i++) spawnNearCamera();
    setInterval(spawnNearCamera, SPAWN_INTERVAL_MS);

    // iOS/Chrome mobile: prime audio on first gesture
    window.addEventListener('pointerdown', ensureAudio, {once:true, passive:true});
  </script>
</body>
</html>
